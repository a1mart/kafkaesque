syntax = "proto3";

package messaging;

option go_package = "./messaging";  // Adjust this to your Go package path

import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "protoc-gen-openapiv2/options/openapiv2.proto";


//metrics/observability; security and authentication... Broker as a CA, mTLS on producer/consumer

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
    info: {
        title: "Kafkaesque API"
        version: "v1"
        description: "Like Kafka";
        contact: {
            name: "Aidan Martin";
            url: "https://github.com/grpc-ecosystem/grpc-gateway";
            email: "aidan3martin@gmail.com";
        };
        license: {
            name: "MIT";
            url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
        };
    };
    external_docs: {
        description: "Documentation";
        url: "https://github.com/grpc-ecosystem/grpc-gateway";
    }
    schemes: [HTTP, HTTPS];
    consumes: "application/json";
    produces: "application/json";
    security_definitions: {
        security: {
            key: "BearerAuth"
            value: {
                type: TYPE_API_KEY  // TYPE_BASIC, TYPE_OAUTH2
                name: "Authorization",
                in: IN_HEADER
            }
        }
        //define multiple schemes if wanted
    };
    // GLOBAL...
    security: {
        security_requirement: {
            key: "BearerAuth"
        }
    }

};

// A generic message structure that can hold any kind of message
message Message {
    string id = 1;  // Unique identifier for the message
    string type = 2; // Type of the message (could relate to the schema)
    bytes payload = 3; // Payload data, can be any data type (serialized)
}

// Request to publish a message
message PublishRequest {
    string topic = 1;   // Topic name
    Message message = 2; // The actual message
}

// Response after publishing a message
message PublishResponse {
    bool success = 1;
    string error = 2;
}

// Request to consume messages
message ConsumeRequest {
    string topic = 1;    // Topic name
    int32 consumer_group = 2;
    int32 batch_size = 3; // Number of messages to consume
}

// Response after consuming messages
message ConsumeResponse {
    repeated Message messages = 1;  // List of messages
    bool success = 2;
    string error = 3;
}

// Request to acknowledge processed messages
message AckRequest {
    string topic = 1;
    string consumer_group = 2;
    repeated string message_ids = 3; // IDs of messages being acknowledged
}

// Response for acknowledgment
message AckResponse {
    bool success = 1;
    string error = 2;
}

message DeadLetterRequest {
    string topic = 1;
    string consumer_group = 2;
    int32 batch_size = 3;
}

message DeadLetterResponse {
    repeated Message messages = 1;
    bool success = 2;
    string error = 3;
}

message RegisterConsumerRequest {
    string consumer_group = 1;
}

message RegisterConsumerResponse {
    bool success = 1;
    string error = 2;
}


// Admin functionality to manage topics and strategies
message CreateTopicRequest {
    string topic = 1; // Topic name
    string strategy = 2; // Distribution strategy (e.g., "round_robin", "broadcast")
}

message CreateTopicResponse {
    bool success = 1;
    string error = 2;
}

message ListTopicsRequest {}

message ListTopicsResponse {
    repeated TopicInfo topics = 1;
}

message TopicInfo {
    string topic = 1;
    string strategy = 2;
}

message ListConsumersRequest {}

message ListConsumersResponse {
    repeated string consumer_groups = 1;
}

service MessagingService {
    rpc Publish(PublishRequest) returns (PublishResponse) {
        option (google.api.http) = {
            post: "/v1/messaging/publish"
            body: "*"
        };

        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
            summary: "Publish messages"
            operation_id: "publish";
            //tags: "msging";
            responses: {
                key: "200"
                value: {
                description: "OK";
                }
            }
            security: {
                security_requirement: {
                    key: "BearerAuth"
                }
            }
        };
    }

    rpc Consume(ConsumeRequest) returns (ConsumeResponse) {
        option (google.api.http) = {
            get: "/v1/messaging/consume"
        };
    }

    rpc Acknowledge(AckRequest) returns (AckResponse) {
        option (google.api.http) = {
            post: "/v1/messaging/acknowledge"
            body: "*"
        };
    }

    rpc GetDeadLetters(DeadLetterRequest) returns (DeadLetterResponse) {
        option (google.api.http) = {
            get: "/v1/messaging/deadletters"
        };
    }

    rpc RegisterConsumerGroup(RegisterConsumerRequest) returns (RegisterConsumerResponse) {
        option (google.api.http) = {
            post: "/v1/messaging/register_consumer"
            body: "*"
        };
    }
}

service AdminService {
    rpc CreateTopic(CreateTopicRequest) returns (CreateTopicResponse) {
        option (google.api.http) = {
            post: "/v1/admin/topics"
            body: "*"
        };
    }

    rpc ListTopics(ListTopicsRequest) returns (ListTopicsResponse) {
        option (google.api.http) = {
            get: "/v1/admin/topics"
        };
    }

    rpc ListConsumers(ListConsumersRequest) returns (ListConsumersResponse) {
        option (google.api.http) = {
            get: "/v1/admin/consumers"
        };
    }
}

// ======================== Schema Registry Service ========================

// Schema Registration Request
message RegisterSchemaRequest {
    string name = 1;        // Schema name (e.g., "UserEvent")
    string type = 2;        // Schema type (e.g., "avro", "json", "protobuf")
    string schema = 3;      // Actual schema content
    string compatibility = 4; // Optional: compatibility mode (e.g., "BACKWARD", "FORWARD", "FULL")
}

// Schema Registration Response
message RegisterSchemaResponse {
    string id = 1;          // Unique schema ID
    int32 version = 2;      // Assigned schema version
}

// Request to get schema by ID
message GetSchemaRequest {
    string id = 1;
}

// Response containing schema details
message GetSchemaResponse {
    string id = 1;
    string name = 2;
    string type = 3;
    string schema = 4;
    int32 version = 5;
}

// Request to get the latest version of a schema
message GetLatestSchemaRequest {
    string name = 1;
}

// Response containing the latest schema version
message GetLatestSchemaResponse {
    string id = 1;
    string name = 2;
    string type = 3;
    string schema = 4;
    int32 version = 5;
}

// Request to list all registered schemas
message ListSchemasRequest {}

// Response containing all schema names
message ListSchemasResponse {
    repeated string schemas = 1;
}

// Request to list all versions of a specific schema
message ListSchemaVersionsRequest {
    string name = 1;
}

// Response containing schema versions
message ListSchemaVersionsResponse {
    repeated int32 versions = 1;
}

// Request for compatibility check
message CheckCompatibilityRequest {
    string name = 1;
    string type = 2;
    string schema = 3;
}

// Response for compatibility check
message CheckCompatibilityResponse {
    bool compatible = 1;
    string reason = 2; // If not compatible, provide reason
}

// Request to delete a schema
message DeleteSchemaRequest {
    string name = 1;
}

// Response for schema deletion
message DeleteSchemaResponse {
    bool success = 1;
    string message = 2;
}

// Request for validating a message against a schema
message ValidateMessageRequest {
    string schema_name = 1;  // The name of the schema to validate against
    int32 version = 2;       // The schema version (optional, defaults to latest)
    string format = 3;       // The format of the message (e.g., "json", "protobuf", "avro")
    bytes message = 4;       // The actual message to validate (raw bytes or JSON string)
}

// Response for validation result
message ValidateMessageResponse {
    bool valid = 1;         // True if the message adheres to the schema
    string error_message = 2; // If invalid, provide details
}

// Schema Registry Service Definition
service SchemaRegistryService {

    // Register a new schema or a new version of an existing schema
    rpc Register(RegisterSchemaRequest) returns (RegisterSchemaResponse) {
        option (google.api.http) = {
            post: "/v1/schemaregistry/register"
            body: "*"
        };
    }

    // Get schema details by ID
    rpc GetSchema(GetSchemaRequest) returns (GetSchemaResponse) {
        option (google.api.http) = {
            get: "/v1/schemaregistry/schema/{id}"
        };
    }

    // Get the latest version of a schema by name
    rpc GetLatestSchema(GetLatestSchemaRequest) returns (GetLatestSchemaResponse) {
        option (google.api.http) = {
            get: "/v1/schemaregistry/latest/{name}"
        };
    }

    // List all registered schemas
    rpc ListSchemas(ListSchemasRequest) returns (ListSchemasResponse) {
        option (google.api.http) = {
            get: "/v1/schemaregistry/list"
        };
    }

    // List all versions of a specific schema
    rpc ListSchemaVersions(ListSchemaVersionsRequest) returns (ListSchemaVersionsResponse) {
        option (google.api.http) = {
            get: "/v1/schemaregistry/versions/{name}"
        };
    }

    // Check if a new schema version is compatible with the existing schema
    rpc CheckCompatibility(CheckCompatibilityRequest) returns (CheckCompatibilityResponse) {
        option (google.api.http) = {
            post: "/v1/schemaregistry/compatibility"
            body: "*"
        };
    }

    // Delete a schema (soft delete)
    rpc DeleteSchema(DeleteSchemaRequest) returns (DeleteSchemaResponse) {
        option (google.api.http) = {
            delete: "/v1/schemaregistry/delete/{name}"
        };
    }

    // Validate a message against a registered schema
    rpc ValidateMessage(ValidateMessageRequest) returns (ValidateMessageResponse) {
        option (google.api.http) = {
            post: "/v1/schemaregistry/validate"
            body: "*"
        };
    }
}

// ======================== Connector Service ========================

// Request to register a connector
message RegisterConnectorRequest {
    string name = 1;                       // Connector name (unique)
    string type = 2;                       // Type of connector (e.g., "source", "sink")
    map<string, string> config = 3;        // Key-value configuration settings
}

// Response containing the registered connector ID
message RegisterConnectorResponse {
    string id = 1;  // Unique identifier for the connector
}

// Request for listing all connectors
message ListConnectorsRequest {}

// Connector metadata
message ConnectorInfo {
    string id = 1;       // Unique connector ID
    string name = 2;     // Connector name
    string type = 3;     // Connector type (source/sink)
    string status = 4;   // Running, stopped, failed, etc.
}

// Response containing a list of connectors
message ListConnectorsResponse {
    repeated ConnectorInfo connectors = 1;
}

// Request for starting/stopping a specific connector
message ConnectorControlRequest {
    string id = 1;  // Connector ID
}

// Response containing updated connector status
message ConnectorControlResponse {
    string id = 1;
    string status = 2;
}

// Request to retrieve details of a specific connector
message GetConnectorRequest {
    string id = 1;
}

// Response containing detailed connector info
message GetConnectorResponse {
    ConnectorInfo connector = 1;
}

// Request to update an existing connector
message UpdateConnectorRequest {
    string id = 1;
    map<string, string> config = 2;  // Updated configuration
}

// Response confirming update success
message UpdateConnectorResponse {
    bool success = 1;
}

// Request to delete a connector
message DeleteConnectorRequest {
    string id = 1;
}

// Response confirming deletion success
message DeleteConnectorResponse {
    bool success = 1;
}

// Request to reset a connector's message offsets
message ResetOffsetsRequest {
    string id = 1;
}

// Response confirming offset reset
message ResetOffsetsResponse {
    bool success = 1;
}

// Request for connector health check
message HealthCheckRequest {
    string id = 1;
}

// Response with health check status
message HealthCheckResponse {
    string status = 1;  // "healthy", "unhealthy", "unknown"
}

message ConnectorLogsRequest {
    string connector_name = 1;
}

message ConnectorLogsResponse {
    repeated string logs = 1;
}

// ======================== Connector Service ========================
service ConnectorService {
    
    // Register a new connector
    rpc Register(RegisterConnectorRequest) returns (RegisterConnectorResponse) {
        option (google.api.http) = {
            post: "/v1/connectors/register"
            body: "*"
        };
    }

    // Start a connector
    rpc Start(ConnectorControlRequest) returns (ConnectorControlResponse) {
        option (google.api.http) = {
            post: "/v1/connectors/start"
            body: "*"
        };
    }

    // Stop a connector
    rpc Stop(ConnectorControlRequest) returns (ConnectorControlResponse) {
        option (google.api.http) = {
            post: "/v1/connectors/stop"
            body: "*"
        };
    }

    // List all connectors
    rpc List(ListConnectorsRequest) returns (ListConnectorsResponse) {
        option (google.api.http) = {
            get: "/v1/connectors/list"
        };
    }

    // Retrieve details of a specific connector
    rpc Get(GetConnectorRequest) returns (GetConnectorResponse) {
        option (google.api.http) = {
            get: "/v1/connectors/{id}"
        };
    }

    // Update an existing connector
    rpc Update(UpdateConnectorRequest) returns (UpdateConnectorResponse) {
        option (google.api.http) = {
            put: "/v1/connectors/{id}/update"
            body: "*"
        };
    }

    // Delete a connector
    rpc Delete(DeleteConnectorRequest) returns (DeleteConnectorResponse) {
        option (google.api.http) = {
            delete: "/v1/connectors/{id}"
        };
    }

    // Reset message offsets for a connector
    rpc ResetOffsets(ResetOffsetsRequest) returns (ResetOffsetsResponse) {
        option (google.api.http) = {
            post: "/v1/connectors/{id}/reset_offsets"
        };
    }

    // Check health of a connector
    rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse) {
        option (google.api.http) = {
            get: "/v1/connectors/{id}/health"
        };
    }

    rpc GetConnectorLogs(ConnectorLogsRequest) returns (ConnectorLogsResponse) {
        option (google.api.http) = {
            get: "/v1/connectors/{id}/logs"
        };
    }
}