// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.2
// source: pkg/proto/huginn/simple.proto

package agentic

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentService_CreateAgent_FullMethodName          = "/agentic.v1.AgentService/CreateAgent"
	AgentService_GetAgent_FullMethodName             = "/agentic.v1.AgentService/GetAgent"
	AgentService_UpdateAgent_FullMethodName          = "/agentic.v1.AgentService/UpdateAgent"
	AgentService_DeleteAgent_FullMethodName          = "/agentic.v1.AgentService/DeleteAgent"
	AgentService_ListAgents_FullMethodName           = "/agentic.v1.AgentService/ListAgents"
	AgentService_ActivateAgent_FullMethodName        = "/agentic.v1.AgentService/ActivateAgent"
	AgentService_DeactivateAgent_FullMethodName      = "/agentic.v1.AgentService/DeactivateAgent"
	AgentService_DryRunAgent_FullMethodName          = "/agentic.v1.AgentService/DryRunAgent"
	AgentService_CheckAgent_FullMethodName           = "/agentic.v1.AgentService/CheckAgent"
	AgentService_GetAgentMemory_FullMethodName       = "/agentic.v1.AgentService/GetAgentMemory"
	AgentService_UpdateAgentMemory_FullMethodName    = "/agentic.v1.AgentService/UpdateAgentMemory"
	AgentService_ReportError_FullMethodName          = "/agentic.v1.AgentService/ReportError"
	AgentService_GetAgentMetrics_FullMethodName      = "/agentic.v1.AgentService/GetAgentMetrics"
	AgentService_GetAgentVersion_FullMethodName      = "/agentic.v1.AgentService/GetAgentVersion"
	AgentService_RollbackAgentVersion_FullMethodName = "/agentic.v1.AgentService/RollbackAgentVersion"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentServiceClient interface {
	// Creates a new agent
	CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	// Retrieves an agent by its unique ID
	GetAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Agent, error)
	// Updates an existing agent
	UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	// Deletes an agent by its unique ID
	DeleteAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Lists all agents with optional pagination
	ListAgents(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// Activates a specific agent
	ActivateAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Deactivates a specific agent
	DeactivateAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Simulates agent actions without committing changes
	DryRunAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Event, error)
	// Checks the health/status of an agent
	CheckAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Retrieves the memory of an agent
	GetAgentMemory(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*MemoryResponse, error)
	// Updates the memory of an agent
	UpdateAgentMemory(ctx context.Context, in *UpdateMemoryRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Reports an error related to an agent
	ReportError(ctx context.Context, in *ReportErrorRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Retrieves performance metrics of an agent
	GetAgentMetrics(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentMetricsResponse, error)
	// Retrieves the current version of an agent
	GetAgentVersion(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentVersionResponse, error)
	// Rolls back an agent to a previous version
	RollbackAgentVersion(ctx context.Context, in *RollbackAgentVersionRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_CreateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_UpdateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeleteAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListAgents(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, AgentService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ActivateAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_ActivateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeactivateAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_DeactivateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DryRunAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, AgentService_DryRunAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) CheckAgent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_CheckAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentMemory(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*MemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAgentMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UpdateAgentMemory(ctx context.Context, in *UpdateMemoryRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_UpdateAgentMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ReportError(ctx context.Context, in *ReportErrorRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_ReportError_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentMetrics(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentMetricsResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAgentMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentVersion(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentVersionResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAgentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) RollbackAgentVersion(ctx context.Context, in *RollbackAgentVersionRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentService_RollbackAgentVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
type AgentServiceServer interface {
	// Creates a new agent
	CreateAgent(context.Context, *CreateAgentRequest) (*Agent, error)
	// Retrieves an agent by its unique ID
	GetAgent(context.Context, *GetByIdRequest) (*Agent, error)
	// Updates an existing agent
	UpdateAgent(context.Context, *UpdateAgentRequest) (*Agent, error)
	// Deletes an agent by its unique ID
	DeleteAgent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Lists all agents with optional pagination
	ListAgents(context.Context, *ListRequest) (*ListAgentsResponse, error)
	// Activates a specific agent
	ActivateAgent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Deactivates a specific agent
	DeactivateAgent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Simulates agent actions without committing changes
	DryRunAgent(context.Context, *GetByIdRequest) (*Event, error)
	// Checks the health/status of an agent
	CheckAgent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Retrieves the memory of an agent
	GetAgentMemory(context.Context, *GetByIdRequest) (*MemoryResponse, error)
	// Updates the memory of an agent
	UpdateAgentMemory(context.Context, *UpdateMemoryRequest) (*BoolResponse, error)
	// Reports an error related to an agent
	ReportError(context.Context, *ReportErrorRequest) (*BoolResponse, error)
	// Retrieves performance metrics of an agent
	GetAgentMetrics(context.Context, *GetByIdRequest) (*AgentMetricsResponse, error)
	// Retrieves the current version of an agent
	GetAgentVersion(context.Context, *GetByIdRequest) (*AgentVersionResponse, error)
	// Rolls back an agent to a previous version
	RollbackAgentVersion(context.Context, *RollbackAgentVersionRequest) (*BoolResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) CreateAgent(context.Context, *CreateAgentRequest) (*Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgent(context.Context, *GetByIdRequest) (*Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServiceServer) UpdateAgent(context.Context, *UpdateAgentRequest) (*Agent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgent not implemented")
}
func (UnimplementedAgentServiceServer) DeleteAgent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAgentServiceServer) ListAgents(context.Context, *ListRequest) (*ListAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServiceServer) ActivateAgent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateAgent not implemented")
}
func (UnimplementedAgentServiceServer) DeactivateAgent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateAgent not implemented")
}
func (UnimplementedAgentServiceServer) DryRunAgent(context.Context, *GetByIdRequest) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DryRunAgent not implemented")
}
func (UnimplementedAgentServiceServer) CheckAgent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentMemory(context.Context, *GetByIdRequest) (*MemoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentMemory not implemented")
}
func (UnimplementedAgentServiceServer) UpdateAgentMemory(context.Context, *UpdateMemoryRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgentMemory not implemented")
}
func (UnimplementedAgentServiceServer) ReportError(context.Context, *ReportErrorRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportError not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentMetrics(context.Context, *GetByIdRequest) (*AgentMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentMetrics not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentVersion(context.Context, *GetByIdRequest) (*AgentVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentVersion not implemented")
}
func (UnimplementedAgentServiceServer) RollbackAgentVersion(context.Context, *RollbackAgentVersionRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackAgentVersion not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call pancis, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_CreateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).CreateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_CreateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).CreateAgent(ctx, req.(*CreateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_UpdateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).UpdateAgent(ctx, req.(*UpdateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeleteAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListAgents(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ActivateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ActivateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ActivateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ActivateAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeactivateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeactivateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeactivateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeactivateAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DryRunAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DryRunAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DryRunAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DryRunAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_CheckAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).CheckAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_CheckAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).CheckAgent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentMemory(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UpdateAgentMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).UpdateAgentMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_UpdateAgentMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).UpdateAgentMemory(ctx, req.(*UpdateMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ReportError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ReportError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ReportError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ReportError(ctx, req.(*ReportErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentMetrics(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentVersion(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_RollbackAgentVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackAgentVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).RollbackAgentVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_RollbackAgentVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).RollbackAgentVersion(ctx, req.(*RollbackAgentVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAgent",
			Handler:    _AgentService_CreateAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AgentService_GetAgent_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _AgentService_UpdateAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _AgentService_DeleteAgent_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _AgentService_ListAgents_Handler,
		},
		{
			MethodName: "ActivateAgent",
			Handler:    _AgentService_ActivateAgent_Handler,
		},
		{
			MethodName: "DeactivateAgent",
			Handler:    _AgentService_DeactivateAgent_Handler,
		},
		{
			MethodName: "DryRunAgent",
			Handler:    _AgentService_DryRunAgent_Handler,
		},
		{
			MethodName: "CheckAgent",
			Handler:    _AgentService_CheckAgent_Handler,
		},
		{
			MethodName: "GetAgentMemory",
			Handler:    _AgentService_GetAgentMemory_Handler,
		},
		{
			MethodName: "UpdateAgentMemory",
			Handler:    _AgentService_UpdateAgentMemory_Handler,
		},
		{
			MethodName: "ReportError",
			Handler:    _AgentService_ReportError_Handler,
		},
		{
			MethodName: "GetAgentMetrics",
			Handler:    _AgentService_GetAgentMetrics_Handler,
		},
		{
			MethodName: "GetAgentVersion",
			Handler:    _AgentService_GetAgentVersion_Handler,
		},
		{
			MethodName: "RollbackAgentVersion",
			Handler:    _AgentService_RollbackAgentVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	AgentLogService_CreateAgentLog_FullMethodName  = "/agentic.v1.AgentLogService/CreateAgentLog"
	AgentLogService_ListAgentLogs_FullMethodName   = "/agentic.v1.AgentLogService/ListAgentLogs"
	AgentLogService_StreamAgentLogs_FullMethodName = "/agentic.v1.AgentLogService/StreamAgentLogs"
	AgentLogService_GetAgentLog_FullMethodName     = "/agentic.v1.AgentLogService/GetAgentLog"
	AgentLogService_StreamAgentLog_FullMethodName  = "/agentic.v1.AgentLogService/StreamAgentLog"
	AgentLogService_ClearLogs_FullMethodName       = "/agentic.v1.AgentLogService/ClearLogs"
)

// AgentLogServiceClient is the client API for AgentLogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentLogServiceClient interface {
	// Creates a new agent log
	CreateAgentLog(ctx context.Context, in *AgentLog, opts ...grpc.CallOption) (*AgentLog, error)
	// Retrieves a list of agent logs with optional pagination
	ListAgentLogs(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListLogsResponse, error)
	// Streams agent logs in real-time
	StreamAgentLogs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentLog], error)
	// Retrieves a specific agent log by its unique ID
	GetAgentLog(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentLog, error)
	// Streams a specific agent log in real-time by its unique ID
	StreamAgentLog(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentLog], error)
	// Clears all logs associated with a specific agent
	ClearLogs(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type agentLogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentLogServiceClient(cc grpc.ClientConnInterface) AgentLogServiceClient {
	return &agentLogServiceClient{cc}
}

func (c *agentLogServiceClient) CreateAgentLog(ctx context.Context, in *AgentLog, opts ...grpc.CallOption) (*AgentLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentLog)
	err := c.cc.Invoke(ctx, AgentLogService_CreateAgentLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentLogServiceClient) ListAgentLogs(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLogsResponse)
	err := c.cc.Invoke(ctx, AgentLogService_ListAgentLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentLogServiceClient) StreamAgentLogs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentLogService_ServiceDesc.Streams[0], AgentLogService_StreamAgentLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, AgentLog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentLogService_StreamAgentLogsClient = grpc.ServerStreamingClient[AgentLog]

func (c *agentLogServiceClient) GetAgentLog(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*AgentLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentLog)
	err := c.cc.Invoke(ctx, AgentLogService_GetAgentLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentLogServiceClient) StreamAgentLog(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentLogService_ServiceDesc.Streams[1], AgentLogService_StreamAgentLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetByIdRequest, AgentLog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentLogService_StreamAgentLogClient = grpc.ServerStreamingClient[AgentLog]

func (c *agentLogServiceClient) ClearLogs(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AgentLogService_ClearLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentLogServiceServer is the server API for AgentLogService service.
// All implementations must embed UnimplementedAgentLogServiceServer
// for forward compatibility.
type AgentLogServiceServer interface {
	// Creates a new agent log
	CreateAgentLog(context.Context, *AgentLog) (*AgentLog, error)
	// Retrieves a list of agent logs with optional pagination
	ListAgentLogs(context.Context, *ListRequest) (*ListLogsResponse, error)
	// Streams agent logs in real-time
	StreamAgentLogs(*Empty, grpc.ServerStreamingServer[AgentLog]) error
	// Retrieves a specific agent log by its unique ID
	GetAgentLog(context.Context, *GetByIdRequest) (*AgentLog, error)
	// Streams a specific agent log in real-time by its unique ID
	StreamAgentLog(*GetByIdRequest, grpc.ServerStreamingServer[AgentLog]) error
	// Clears all logs associated with a specific agent
	ClearLogs(context.Context, *GetByIdRequest) (*BoolResponse, error)
	mustEmbedUnimplementedAgentLogServiceServer()
}

// UnimplementedAgentLogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentLogServiceServer struct{}

func (UnimplementedAgentLogServiceServer) CreateAgentLog(context.Context, *AgentLog) (*AgentLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAgentLog not implemented")
}
func (UnimplementedAgentLogServiceServer) ListAgentLogs(context.Context, *ListRequest) (*ListLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgentLogs not implemented")
}
func (UnimplementedAgentLogServiceServer) StreamAgentLogs(*Empty, grpc.ServerStreamingServer[AgentLog]) error {
	return status.Errorf(codes.Unimplemented, "method StreamAgentLogs not implemented")
}
func (UnimplementedAgentLogServiceServer) GetAgentLog(context.Context, *GetByIdRequest) (*AgentLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentLog not implemented")
}
func (UnimplementedAgentLogServiceServer) StreamAgentLog(*GetByIdRequest, grpc.ServerStreamingServer[AgentLog]) error {
	return status.Errorf(codes.Unimplemented, "method StreamAgentLog not implemented")
}
func (UnimplementedAgentLogServiceServer) ClearLogs(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearLogs not implemented")
}
func (UnimplementedAgentLogServiceServer) mustEmbedUnimplementedAgentLogServiceServer() {}
func (UnimplementedAgentLogServiceServer) testEmbeddedByValue()                         {}

// UnsafeAgentLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentLogServiceServer will
// result in compilation errors.
type UnsafeAgentLogServiceServer interface {
	mustEmbedUnimplementedAgentLogServiceServer()
}

func RegisterAgentLogServiceServer(s grpc.ServiceRegistrar, srv AgentLogServiceServer) {
	// If the following call pancis, it indicates UnimplementedAgentLogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentLogService_ServiceDesc, srv)
}

func _AgentLogService_CreateAgentLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentLog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentLogServiceServer).CreateAgentLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentLogService_CreateAgentLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentLogServiceServer).CreateAgentLog(ctx, req.(*AgentLog))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentLogService_ListAgentLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentLogServiceServer).ListAgentLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentLogService_ListAgentLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentLogServiceServer).ListAgentLogs(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentLogService_StreamAgentLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentLogServiceServer).StreamAgentLogs(m, &grpc.GenericServerStream[Empty, AgentLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentLogService_StreamAgentLogsServer = grpc.ServerStreamingServer[AgentLog]

func _AgentLogService_GetAgentLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentLogServiceServer).GetAgentLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentLogService_GetAgentLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentLogServiceServer).GetAgentLog(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentLogService_StreamAgentLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetByIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentLogServiceServer).StreamAgentLog(m, &grpc.GenericServerStream[GetByIdRequest, AgentLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentLogService_StreamAgentLogServer = grpc.ServerStreamingServer[AgentLog]

func _AgentLogService_ClearLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentLogServiceServer).ClearLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentLogService_ClearLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentLogServiceServer).ClearLogs(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentLogService_ServiceDesc is the grpc.ServiceDesc for AgentLogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentLogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.AgentLogService",
	HandlerType: (*AgentLogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAgentLog",
			Handler:    _AgentLogService_CreateAgentLog_Handler,
		},
		{
			MethodName: "ListAgentLogs",
			Handler:    _AgentLogService_ListAgentLogs_Handler,
		},
		{
			MethodName: "GetAgentLog",
			Handler:    _AgentLogService_GetAgentLog_Handler,
		},
		{
			MethodName: "ClearLogs",
			Handler:    _AgentLogService_ClearLogs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAgentLogs",
			Handler:       _AgentLogService_StreamAgentLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAgentLog",
			Handler:       _AgentLogService_StreamAgentLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	EventService_CreateEvent_FullMethodName      = "/agentic.v1.EventService/CreateEvent"
	EventService_GetEvent_FullMethodName         = "/agentic.v1.EventService/GetEvent"
	EventService_ListEvents_FullMethodName       = "/agentic.v1.EventService/ListEvents"
	EventService_StreamEvents_FullMethodName     = "/agentic.v1.EventService/StreamEvents"
	EventService_ExpireEvent_FullMethodName      = "/agentic.v1.EventService/ExpireEvent"
	EventService_AcknowledgeEvent_FullMethodName = "/agentic.v1.EventService/AcknowledgeEvent"
	EventService_ReplayEvent_FullMethodName      = "/agentic.v1.EventService/ReplayEvent"
	EventService_ListEventsByType_FullMethodName = "/agentic.v1.EventService/ListEventsByType"
	EventService_CancelEvent_FullMethodName      = "/agentic.v1.EventService/CancelEvent"
	EventService_RescheduleEvent_FullMethodName  = "/agentic.v1.EventService/RescheduleEvent"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// / Service for managing events.
type EventServiceClient interface {
	// / Create a new event.
	CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	// / Get details of a specific event by its ID.
	GetEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Event, error)
	// / List all events with optional pagination.
	ListEvents(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	// / Stream real-time events.
	StreamEvents(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error)
	// / Expire an event, marking it as no longer active.
	ExpireEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// / Acknowledge an event, confirming its receipt.
	AcknowledgeEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// / Replay an event, re-triggering its behavior.
	ReplayEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// / List events filtered by their type.
	ListEventsByType(ctx context.Context, in *EventTypeRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	// / Cancel an event, stopping any future execution.
	CancelEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// / Reschedule an event to a new time.
	RescheduleEvent(ctx context.Context, in *RescheduleEventRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, EventService_CreateEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Event, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Event)
	err := c.cc.Invoke(ctx, EventService_GetEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListEvents(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEventsResponse)
	err := c.cc.Invoke(ctx, EventService_ListEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) StreamEvents(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[0], EventService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_StreamEventsClient = grpc.ServerStreamingClient[Event]

func (c *eventServiceClient) ExpireEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EventService_ExpireEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) AcknowledgeEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EventService_AcknowledgeEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ReplayEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EventService_ReplayEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListEventsByType(ctx context.Context, in *EventTypeRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEventsResponse)
	err := c.cc.Invoke(ctx, EventService_ListEventsByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) CancelEvent(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EventService_CancelEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) RescheduleEvent(ctx context.Context, in *RescheduleEventRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, EventService_RescheduleEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
//
// / Service for managing events.
type EventServiceServer interface {
	// / Create a new event.
	CreateEvent(context.Context, *Event) (*Event, error)
	// / Get details of a specific event by its ID.
	GetEvent(context.Context, *GetByIdRequest) (*Event, error)
	// / List all events with optional pagination.
	ListEvents(context.Context, *ListRequest) (*ListEventsResponse, error)
	// / Stream real-time events.
	StreamEvents(*Empty, grpc.ServerStreamingServer[Event]) error
	// / Expire an event, marking it as no longer active.
	ExpireEvent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// / Acknowledge an event, confirming its receipt.
	AcknowledgeEvent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// / Replay an event, re-triggering its behavior.
	ReplayEvent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// / List events filtered by their type.
	ListEventsByType(context.Context, *EventTypeRequest) (*ListEventsResponse, error)
	// / Cancel an event, stopping any future execution.
	CancelEvent(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// / Reschedule an event to a new time.
	RescheduleEvent(context.Context, *RescheduleEventRequest) (*BoolResponse, error)
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) CreateEvent(context.Context, *Event) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEvent not implemented")
}
func (UnimplementedEventServiceServer) GetEvent(context.Context, *GetByIdRequest) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvent not implemented")
}
func (UnimplementedEventServiceServer) ListEvents(context.Context, *ListRequest) (*ListEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedEventServiceServer) StreamEvents(*Empty, grpc.ServerStreamingServer[Event]) error {
	return status.Errorf(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedEventServiceServer) ExpireEvent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpireEvent not implemented")
}
func (UnimplementedEventServiceServer) AcknowledgeEvent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcknowledgeEvent not implemented")
}
func (UnimplementedEventServiceServer) ReplayEvent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplayEvent not implemented")
}
func (UnimplementedEventServiceServer) ListEventsByType(context.Context, *EventTypeRequest) (*ListEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEventsByType not implemented")
}
func (UnimplementedEventServiceServer) CancelEvent(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelEvent not implemented")
}
func (UnimplementedEventServiceServer) RescheduleEvent(context.Context, *RescheduleEventRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RescheduleEvent not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call pancis, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetEvent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_ListEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).ListEvents(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).StreamEvents(m, &grpc.GenericServerStream[Empty, Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_StreamEventsServer = grpc.ServerStreamingServer[Event]

func _EventService_ExpireEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).ExpireEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_ExpireEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).ExpireEvent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_AcknowledgeEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).AcknowledgeEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_AcknowledgeEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).AcknowledgeEvent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ReplayEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).ReplayEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_ReplayEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).ReplayEvent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListEventsByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).ListEventsByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_ListEventsByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).ListEventsByType(ctx, req.(*EventTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_CancelEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CancelEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CancelEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CancelEvent(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_RescheduleEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RescheduleEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).RescheduleEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_RescheduleEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).RescheduleEvent(ctx, req.(*RescheduleEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEvent",
			Handler:    _EventService_CreateEvent_Handler,
		},
		{
			MethodName: "GetEvent",
			Handler:    _EventService_GetEvent_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _EventService_ListEvents_Handler,
		},
		{
			MethodName: "ExpireEvent",
			Handler:    _EventService_ExpireEvent_Handler,
		},
		{
			MethodName: "AcknowledgeEvent",
			Handler:    _EventService_AcknowledgeEvent_Handler,
		},
		{
			MethodName: "ReplayEvent",
			Handler:    _EventService_ReplayEvent_Handler,
		},
		{
			MethodName: "ListEventsByType",
			Handler:    _EventService_ListEventsByType_Handler,
		},
		{
			MethodName: "CancelEvent",
			Handler:    _EventService_CancelEvent_Handler,
		},
		{
			MethodName: "RescheduleEvent",
			Handler:    _EventService_RescheduleEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEvents",
			Handler:       _EventService_StreamEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	DelayedJobService_EnqueueJob_FullMethodName = "/agentic.v1.DelayedJobService/EnqueueJob"
	DelayedJobService_GetJob_FullMethodName     = "/agentic.v1.DelayedJobService/GetJob"
	DelayedJobService_UpdateJob_FullMethodName  = "/agentic.v1.DelayedJobService/UpdateJob"
	DelayedJobService_DeleteJob_FullMethodName  = "/agentic.v1.DelayedJobService/DeleteJob"
	DelayedJobService_RunJob_FullMethodName     = "/agentic.v1.DelayedJobService/RunJob"
	DelayedJobService_ListJobs_FullMethodName   = "/agentic.v1.DelayedJobService/ListJobs"
)

// DelayedJobServiceClient is the client API for DelayedJobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for managing delayed jobs
type DelayedJobServiceClient interface {
	// Enqueue a new delayed job
	EnqueueJob(ctx context.Context, in *DelayedJob, opts ...grpc.CallOption) (*DelayedJob, error)
	// Retrieve a delayed job by its unique ID
	GetJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*DelayedJob, error)
	// Update an existing delayed job
	UpdateJob(ctx context.Context, in *DelayedJob, opts ...grpc.CallOption) (*DelayedJob, error)
	// Delete a delayed job by its unique ID
	DeleteJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Manually trigger execution of a delayed job
	RunJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// List all delayed jobs with optional pagination
	ListJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListJobsResponse, error)
}

type delayedJobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDelayedJobServiceClient(cc grpc.ClientConnInterface) DelayedJobServiceClient {
	return &delayedJobServiceClient{cc}
}

func (c *delayedJobServiceClient) EnqueueJob(ctx context.Context, in *DelayedJob, opts ...grpc.CallOption) (*DelayedJob, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelayedJob)
	err := c.cc.Invoke(ctx, DelayedJobService_EnqueueJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delayedJobServiceClient) GetJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*DelayedJob, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelayedJob)
	err := c.cc.Invoke(ctx, DelayedJobService_GetJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delayedJobServiceClient) UpdateJob(ctx context.Context, in *DelayedJob, opts ...grpc.CallOption) (*DelayedJob, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DelayedJob)
	err := c.cc.Invoke(ctx, DelayedJobService_UpdateJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delayedJobServiceClient) DeleteJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, DelayedJobService_DeleteJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delayedJobServiceClient) RunJob(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, DelayedJobService_RunJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delayedJobServiceClient) ListJobs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListJobsResponse)
	err := c.cc.Invoke(ctx, DelayedJobService_ListJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DelayedJobServiceServer is the server API for DelayedJobService service.
// All implementations must embed UnimplementedDelayedJobServiceServer
// for forward compatibility.
//
// Service for managing delayed jobs
type DelayedJobServiceServer interface {
	// Enqueue a new delayed job
	EnqueueJob(context.Context, *DelayedJob) (*DelayedJob, error)
	// Retrieve a delayed job by its unique ID
	GetJob(context.Context, *GetByIdRequest) (*DelayedJob, error)
	// Update an existing delayed job
	UpdateJob(context.Context, *DelayedJob) (*DelayedJob, error)
	// Delete a delayed job by its unique ID
	DeleteJob(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Manually trigger execution of a delayed job
	RunJob(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// List all delayed jobs with optional pagination
	ListJobs(context.Context, *Empty) (*ListJobsResponse, error)
	mustEmbedUnimplementedDelayedJobServiceServer()
}

// UnimplementedDelayedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDelayedJobServiceServer struct{}

func (UnimplementedDelayedJobServiceServer) EnqueueJob(context.Context, *DelayedJob) (*DelayedJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueJob not implemented")
}
func (UnimplementedDelayedJobServiceServer) GetJob(context.Context, *GetByIdRequest) (*DelayedJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedDelayedJobServiceServer) UpdateJob(context.Context, *DelayedJob) (*DelayedJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJob not implemented")
}
func (UnimplementedDelayedJobServiceServer) DeleteJob(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedDelayedJobServiceServer) RunJob(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunJob not implemented")
}
func (UnimplementedDelayedJobServiceServer) ListJobs(context.Context, *Empty) (*ListJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedDelayedJobServiceServer) mustEmbedUnimplementedDelayedJobServiceServer() {}
func (UnimplementedDelayedJobServiceServer) testEmbeddedByValue()                           {}

// UnsafeDelayedJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DelayedJobServiceServer will
// result in compilation errors.
type UnsafeDelayedJobServiceServer interface {
	mustEmbedUnimplementedDelayedJobServiceServer()
}

func RegisterDelayedJobServiceServer(s grpc.ServiceRegistrar, srv DelayedJobServiceServer) {
	// If the following call pancis, it indicates UnimplementedDelayedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DelayedJobService_ServiceDesc, srv)
}

func _DelayedJobService_EnqueueJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelayedJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).EnqueueJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_EnqueueJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).EnqueueJob(ctx, req.(*DelayedJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _DelayedJobService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).GetJob(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DelayedJobService_UpdateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelayedJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).UpdateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_UpdateJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).UpdateJob(ctx, req.(*DelayedJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _DelayedJobService_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).DeleteJob(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DelayedJobService_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_RunJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).RunJob(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DelayedJobService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelayedJobServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DelayedJobService_ListJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelayedJobServiceServer).ListJobs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DelayedJobService_ServiceDesc is the grpc.ServiceDesc for DelayedJobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DelayedJobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.DelayedJobService",
	HandlerType: (*DelayedJobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnqueueJob",
			Handler:    _DelayedJobService_EnqueueJob_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _DelayedJobService_GetJob_Handler,
		},
		{
			MethodName: "UpdateJob",
			Handler:    _DelayedJobService_UpdateJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _DelayedJobService_DeleteJob_Handler,
		},
		{
			MethodName: "RunJob",
			Handler:    _DelayedJobService_RunJob_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _DelayedJobService_ListJobs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	LinkService_CreateLink_FullMethodName          = "/agentic.v1.LinkService/CreateLink"
	LinkService_DeleteLink_FullMethodName          = "/agentic.v1.LinkService/DeleteLink"
	LinkService_ListLinks_FullMethodName           = "/agentic.v1.LinkService/ListLinks"
	LinkService_FindLinksBySourceId_FullMethodName = "/agentic.v1.LinkService/FindLinksBySourceId"
)

// LinkServiceClient is the client API for LinkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LinkServiceClient interface {
	// Create a new link between two entities
	CreateLink(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*Link, error)
	// Delete a link by its unique identifier
	DeleteLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// List all existing links
	ListLinks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListLinksResponse, error)
	// Find links by the source agent's ID
	FindLinksBySourceId(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListLinksResponse, error)
}

type linkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLinkServiceClient(cc grpc.ClientConnInterface) LinkServiceClient {
	return &linkServiceClient{cc}
}

func (c *linkServiceClient) CreateLink(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*Link, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Link)
	err := c.cc.Invoke(ctx, LinkService_CreateLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkServiceClient) DeleteLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, LinkService_DeleteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkServiceClient) ListLinks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLinksResponse)
	err := c.cc.Invoke(ctx, LinkService_ListLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkServiceClient) FindLinksBySourceId(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLinksResponse)
	err := c.cc.Invoke(ctx, LinkService_FindLinksBySourceId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LinkServiceServer is the server API for LinkService service.
// All implementations must embed UnimplementedLinkServiceServer
// for forward compatibility.
type LinkServiceServer interface {
	// Create a new link between two entities
	CreateLink(context.Context, *TwoIdRequest) (*Link, error)
	// Delete a link by its unique identifier
	DeleteLink(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// List all existing links
	ListLinks(context.Context, *Empty) (*ListLinksResponse, error)
	// Find links by the source agent's ID
	FindLinksBySourceId(context.Context, *GetByIdRequest) (*ListLinksResponse, error)
	mustEmbedUnimplementedLinkServiceServer()
}

// UnimplementedLinkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLinkServiceServer struct{}

func (UnimplementedLinkServiceServer) CreateLink(context.Context, *TwoIdRequest) (*Link, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLink not implemented")
}
func (UnimplementedLinkServiceServer) DeleteLink(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLink not implemented")
}
func (UnimplementedLinkServiceServer) ListLinks(context.Context, *Empty) (*ListLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLinks not implemented")
}
func (UnimplementedLinkServiceServer) FindLinksBySourceId(context.Context, *GetByIdRequest) (*ListLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindLinksBySourceId not implemented")
}
func (UnimplementedLinkServiceServer) mustEmbedUnimplementedLinkServiceServer() {}
func (UnimplementedLinkServiceServer) testEmbeddedByValue()                     {}

// UnsafeLinkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LinkServiceServer will
// result in compilation errors.
type UnsafeLinkServiceServer interface {
	mustEmbedUnimplementedLinkServiceServer()
}

func RegisterLinkServiceServer(s grpc.ServiceRegistrar, srv LinkServiceServer) {
	// If the following call pancis, it indicates UnimplementedLinkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LinkService_ServiceDesc, srv)
}

func _LinkService_CreateLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServiceServer).CreateLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkService_CreateLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServiceServer).CreateLink(ctx, req.(*TwoIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkService_DeleteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServiceServer).DeleteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkService_DeleteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServiceServer).DeleteLink(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkService_ListLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServiceServer).ListLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkService_ListLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServiceServer).ListLinks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkService_FindLinksBySourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkServiceServer).FindLinksBySourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkService_FindLinksBySourceId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkServiceServer).FindLinksBySourceId(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LinkService_ServiceDesc is the grpc.ServiceDesc for LinkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LinkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.LinkService",
	HandlerType: (*LinkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLink",
			Handler:    _LinkService_CreateLink_Handler,
		},
		{
			MethodName: "DeleteLink",
			Handler:    _LinkService_DeleteLink_Handler,
		},
		{
			MethodName: "ListLinks",
			Handler:    _LinkService_ListLinks_Handler,
		},
		{
			MethodName: "FindLinksBySourceId",
			Handler:    _LinkService_FindLinksBySourceId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	ControlService_CreateControlLink_FullMethodName     = "/agentic.v1.ControlService/CreateControlLink"
	ControlService_DeleteControlLink_FullMethodName     = "/agentic.v1.ControlService/DeleteControlLink"
	ControlService_ListControlLinks_FullMethodName      = "/agentic.v1.ControlService/ListControlLinks"
	ControlService_FindLinksBySourceId_FullMethodName   = "/agentic.v1.ControlService/FindLinksBySourceId"
	ControlService_ActivateControlLink_FullMethodName   = "/agentic.v1.ControlService/ActivateControlLink"
	ControlService_DeactivateControlLink_FullMethodName = "/agentic.v1.ControlService/DeactivateControlLink"
)

// ControlServiceClient is the client API for ControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControlServiceClient interface {
	// Create a new control link
	CreateControlLink(ctx context.Context, in *ControlLink, opts ...grpc.CallOption) (*ControlLink, error)
	// Delete a control link by its unique identifier
	DeleteControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// List all existing control links
	ListControlLinks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListControlLinksResponse, error)
	// Find control links by the source agent's ID
	FindLinksBySourceId(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListLinksResponse, error)
	// Activate a specific control link
	ActivateControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Deactivate a specific control link
	DeactivateControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type controlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewControlServiceClient(cc grpc.ClientConnInterface) ControlServiceClient {
	return &controlServiceClient{cc}
}

func (c *controlServiceClient) CreateControlLink(ctx context.Context, in *ControlLink, opts ...grpc.CallOption) (*ControlLink, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ControlLink)
	err := c.cc.Invoke(ctx, ControlService_CreateControlLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) DeleteControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ControlService_DeleteControlLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ListControlLinks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListControlLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListControlLinksResponse)
	err := c.cc.Invoke(ctx, ControlService_ListControlLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) FindLinksBySourceId(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLinksResponse)
	err := c.cc.Invoke(ctx, ControlService_FindLinksBySourceId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ActivateControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ControlService_ActivateControlLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) DeactivateControlLink(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ControlService_DeactivateControlLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControlServiceServer is the server API for ControlService service.
// All implementations must embed UnimplementedControlServiceServer
// for forward compatibility.
type ControlServiceServer interface {
	// Create a new control link
	CreateControlLink(context.Context, *ControlLink) (*ControlLink, error)
	// Delete a control link by its unique identifier
	DeleteControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// List all existing control links
	ListControlLinks(context.Context, *Empty) (*ListControlLinksResponse, error)
	// Find control links by the source agent's ID
	FindLinksBySourceId(context.Context, *GetByIdRequest) (*ListLinksResponse, error)
	// Activate a specific control link
	ActivateControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Deactivate a specific control link
	DeactivateControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error)
	mustEmbedUnimplementedControlServiceServer()
}

// UnimplementedControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedControlServiceServer struct{}

func (UnimplementedControlServiceServer) CreateControlLink(context.Context, *ControlLink) (*ControlLink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateControlLink not implemented")
}
func (UnimplementedControlServiceServer) DeleteControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteControlLink not implemented")
}
func (UnimplementedControlServiceServer) ListControlLinks(context.Context, *Empty) (*ListControlLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListControlLinks not implemented")
}
func (UnimplementedControlServiceServer) FindLinksBySourceId(context.Context, *GetByIdRequest) (*ListLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindLinksBySourceId not implemented")
}
func (UnimplementedControlServiceServer) ActivateControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateControlLink not implemented")
}
func (UnimplementedControlServiceServer) DeactivateControlLink(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateControlLink not implemented")
}
func (UnimplementedControlServiceServer) mustEmbedUnimplementedControlServiceServer() {}
func (UnimplementedControlServiceServer) testEmbeddedByValue()                        {}

// UnsafeControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControlServiceServer will
// result in compilation errors.
type UnsafeControlServiceServer interface {
	mustEmbedUnimplementedControlServiceServer()
}

func RegisterControlServiceServer(s grpc.ServiceRegistrar, srv ControlServiceServer) {
	// If the following call pancis, it indicates UnimplementedControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ControlService_ServiceDesc, srv)
}

func _ControlService_CreateControlLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlLink)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).CreateControlLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_CreateControlLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).CreateControlLink(ctx, req.(*ControlLink))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_DeleteControlLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).DeleteControlLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_DeleteControlLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).DeleteControlLink(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ListControlLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ListControlLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ListControlLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ListControlLinks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_FindLinksBySourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).FindLinksBySourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_FindLinksBySourceId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).FindLinksBySourceId(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ActivateControlLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ActivateControlLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ActivateControlLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ActivateControlLink(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_DeactivateControlLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).DeactivateControlLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_DeactivateControlLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).DeactivateControlLink(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ControlService_ServiceDesc is the grpc.ServiceDesc for ControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.ControlService",
	HandlerType: (*ControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateControlLink",
			Handler:    _ControlService_CreateControlLink_Handler,
		},
		{
			MethodName: "DeleteControlLink",
			Handler:    _ControlService_DeleteControlLink_Handler,
		},
		{
			MethodName: "ListControlLinks",
			Handler:    _ControlService_ListControlLinks_Handler,
		},
		{
			MethodName: "FindLinksBySourceId",
			Handler:    _ControlService_FindLinksBySourceId_Handler,
		},
		{
			MethodName: "ActivateControlLink",
			Handler:    _ControlService_ActivateControlLink_Handler,
		},
		{
			MethodName: "DeactivateControlLink",
			Handler:    _ControlService_DeactivateControlLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	ScenarioService_CreateScenario_FullMethodName          = "/agentic.v1.ScenarioService/CreateScenario"
	ScenarioService_GetScenario_FullMethodName             = "/agentic.v1.ScenarioService/GetScenario"
	ScenarioService_UpdateScenario_FullMethodName          = "/agentic.v1.ScenarioService/UpdateScenario"
	ScenarioService_DeleteScenario_FullMethodName          = "/agentic.v1.ScenarioService/DeleteScenario"
	ScenarioService_ListScenarios_FullMethodName           = "/agentic.v1.ScenarioService/ListScenarios"
	ScenarioService_ImportScenario_FullMethodName          = "/agentic.v1.ScenarioService/ImportScenario"
	ScenarioService_ExportScenario_FullMethodName          = "/agentic.v1.ScenarioService/ExportScenario"
	ScenarioService_AddAgentToScenario_FullMethodName      = "/agentic.v1.ScenarioService/AddAgentToScenario"
	ScenarioService_RemoveAgentFromScenario_FullMethodName = "/agentic.v1.ScenarioService/RemoveAgentFromScenario"
	ScenarioService_StartScenario_FullMethodName           = "/agentic.v1.ScenarioService/StartScenario"
	ScenarioService_PauseScenario_FullMethodName           = "/agentic.v1.ScenarioService/PauseScenario"
	ScenarioService_ResumeScenario_FullMethodName          = "/agentic.v1.ScenarioService/ResumeScenario"
)

// ScenarioServiceClient is the client API for ScenarioService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScenarioServiceClient interface {
	// Create a new scenario
	CreateScenario(ctx context.Context, in *Scenario, opts ...grpc.CallOption) (*Scenario, error)
	// Retrieve a scenario by its unique identifier
	GetScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Scenario, error)
	// Update an existing scenario by its unique identifier
	UpdateScenario(ctx context.Context, in *Scenario, opts ...grpc.CallOption) (*Scenario, error)
	// Delete a scenario by its unique identifier
	DeleteScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// List all existing scenarios
	ListScenarios(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListScenariosResponse, error)
	// Import a scenario from a JSON object
	ImportScenario(ctx context.Context, in *JsonObject, opts ...grpc.CallOption) (*Scenario, error)
	// Export a scenario as a JSON object
	ExportScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*JsonObject, error)
	// Add an agent to a scenario by providing scenario and agent IDs
	AddAgentToScenario(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Remove an agent from a scenario by providing scenario and agent IDs
	RemoveAgentFromScenario(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Start execution of a specific scenario
	StartScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Pause execution of a specific scenario
	PauseScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Resume execution of a paused scenario
	ResumeScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type scenarioServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScenarioServiceClient(cc grpc.ClientConnInterface) ScenarioServiceClient {
	return &scenarioServiceClient{cc}
}

func (c *scenarioServiceClient) CreateScenario(ctx context.Context, in *Scenario, opts ...grpc.CallOption) (*Scenario, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scenario)
	err := c.cc.Invoke(ctx, ScenarioService_CreateScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) GetScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*Scenario, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scenario)
	err := c.cc.Invoke(ctx, ScenarioService_GetScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) UpdateScenario(ctx context.Context, in *Scenario, opts ...grpc.CallOption) (*Scenario, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scenario)
	err := c.cc.Invoke(ctx, ScenarioService_UpdateScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) DeleteScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_DeleteScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) ListScenarios(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListScenariosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListScenariosResponse)
	err := c.cc.Invoke(ctx, ScenarioService_ListScenarios_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) ImportScenario(ctx context.Context, in *JsonObject, opts ...grpc.CallOption) (*Scenario, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scenario)
	err := c.cc.Invoke(ctx, ScenarioService_ImportScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) ExportScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*JsonObject, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonObject)
	err := c.cc.Invoke(ctx, ScenarioService_ExportScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) AddAgentToScenario(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_AddAgentToScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) RemoveAgentFromScenario(ctx context.Context, in *TwoIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_RemoveAgentFromScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) StartScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_StartScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) PauseScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_PauseScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scenarioServiceClient) ResumeScenario(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScenarioService_ResumeScenario_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScenarioServiceServer is the server API for ScenarioService service.
// All implementations must embed UnimplementedScenarioServiceServer
// for forward compatibility.
type ScenarioServiceServer interface {
	// Create a new scenario
	CreateScenario(context.Context, *Scenario) (*Scenario, error)
	// Retrieve a scenario by its unique identifier
	GetScenario(context.Context, *GetByIdRequest) (*Scenario, error)
	// Update an existing scenario by its unique identifier
	UpdateScenario(context.Context, *Scenario) (*Scenario, error)
	// Delete a scenario by its unique identifier
	DeleteScenario(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// List all existing scenarios
	ListScenarios(context.Context, *Empty) (*ListScenariosResponse, error)
	// Import a scenario from a JSON object
	ImportScenario(context.Context, *JsonObject) (*Scenario, error)
	// Export a scenario as a JSON object
	ExportScenario(context.Context, *GetByIdRequest) (*JsonObject, error)
	// Add an agent to a scenario by providing scenario and agent IDs
	AddAgentToScenario(context.Context, *TwoIdRequest) (*BoolResponse, error)
	// Remove an agent from a scenario by providing scenario and agent IDs
	RemoveAgentFromScenario(context.Context, *TwoIdRequest) (*BoolResponse, error)
	// Start execution of a specific scenario
	StartScenario(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Pause execution of a specific scenario
	PauseScenario(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Resume execution of a paused scenario
	ResumeScenario(context.Context, *GetByIdRequest) (*BoolResponse, error)
	mustEmbedUnimplementedScenarioServiceServer()
}

// UnimplementedScenarioServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScenarioServiceServer struct{}

func (UnimplementedScenarioServiceServer) CreateScenario(context.Context, *Scenario) (*Scenario, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateScenario not implemented")
}
func (UnimplementedScenarioServiceServer) GetScenario(context.Context, *GetByIdRequest) (*Scenario, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScenario not implemented")
}
func (UnimplementedScenarioServiceServer) UpdateScenario(context.Context, *Scenario) (*Scenario, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScenario not implemented")
}
func (UnimplementedScenarioServiceServer) DeleteScenario(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScenario not implemented")
}
func (UnimplementedScenarioServiceServer) ListScenarios(context.Context, *Empty) (*ListScenariosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListScenarios not implemented")
}
func (UnimplementedScenarioServiceServer) ImportScenario(context.Context, *JsonObject) (*Scenario, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportScenario not implemented")
}
func (UnimplementedScenarioServiceServer) ExportScenario(context.Context, *GetByIdRequest) (*JsonObject, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportScenario not implemented")
}
func (UnimplementedScenarioServiceServer) AddAgentToScenario(context.Context, *TwoIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAgentToScenario not implemented")
}
func (UnimplementedScenarioServiceServer) RemoveAgentFromScenario(context.Context, *TwoIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAgentFromScenario not implemented")
}
func (UnimplementedScenarioServiceServer) StartScenario(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartScenario not implemented")
}
func (UnimplementedScenarioServiceServer) PauseScenario(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseScenario not implemented")
}
func (UnimplementedScenarioServiceServer) ResumeScenario(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeScenario not implemented")
}
func (UnimplementedScenarioServiceServer) mustEmbedUnimplementedScenarioServiceServer() {}
func (UnimplementedScenarioServiceServer) testEmbeddedByValue()                         {}

// UnsafeScenarioServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScenarioServiceServer will
// result in compilation errors.
type UnsafeScenarioServiceServer interface {
	mustEmbedUnimplementedScenarioServiceServer()
}

func RegisterScenarioServiceServer(s grpc.ServiceRegistrar, srv ScenarioServiceServer) {
	// If the following call pancis, it indicates UnimplementedScenarioServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ScenarioService_ServiceDesc, srv)
}

func _ScenarioService_CreateScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Scenario)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).CreateScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_CreateScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).CreateScenario(ctx, req.(*Scenario))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_GetScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).GetScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_GetScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).GetScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_UpdateScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Scenario)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).UpdateScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_UpdateScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).UpdateScenario(ctx, req.(*Scenario))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_DeleteScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).DeleteScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_DeleteScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).DeleteScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_ListScenarios_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).ListScenarios(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_ListScenarios_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).ListScenarios(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_ImportScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JsonObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).ImportScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_ImportScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).ImportScenario(ctx, req.(*JsonObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_ExportScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).ExportScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_ExportScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).ExportScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_AddAgentToScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).AddAgentToScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_AddAgentToScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).AddAgentToScenario(ctx, req.(*TwoIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_RemoveAgentFromScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).RemoveAgentFromScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_RemoveAgentFromScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).RemoveAgentFromScenario(ctx, req.(*TwoIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_StartScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).StartScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_StartScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).StartScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_PauseScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).PauseScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_PauseScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).PauseScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScenarioService_ResumeScenario_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScenarioServiceServer).ResumeScenario(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScenarioService_ResumeScenario_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScenarioServiceServer).ResumeScenario(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ScenarioService_ServiceDesc is the grpc.ServiceDesc for ScenarioService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScenarioService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.ScenarioService",
	HandlerType: (*ScenarioServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateScenario",
			Handler:    _ScenarioService_CreateScenario_Handler,
		},
		{
			MethodName: "GetScenario",
			Handler:    _ScenarioService_GetScenario_Handler,
		},
		{
			MethodName: "UpdateScenario",
			Handler:    _ScenarioService_UpdateScenario_Handler,
		},
		{
			MethodName: "DeleteScenario",
			Handler:    _ScenarioService_DeleteScenario_Handler,
		},
		{
			MethodName: "ListScenarios",
			Handler:    _ScenarioService_ListScenarios_Handler,
		},
		{
			MethodName: "ImportScenario",
			Handler:    _ScenarioService_ImportScenario_Handler,
		},
		{
			MethodName: "ExportScenario",
			Handler:    _ScenarioService_ExportScenario_Handler,
		},
		{
			MethodName: "AddAgentToScenario",
			Handler:    _ScenarioService_AddAgentToScenario_Handler,
		},
		{
			MethodName: "RemoveAgentFromScenario",
			Handler:    _ScenarioService_RemoveAgentFromScenario_Handler,
		},
		{
			MethodName: "StartScenario",
			Handler:    _ScenarioService_StartScenario_Handler,
		},
		{
			MethodName: "PauseScenario",
			Handler:    _ScenarioService_PauseScenario_Handler,
		},
		{
			MethodName: "ResumeScenario",
			Handler:    _ScenarioService_ResumeScenario_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	UserService_CreateUser_FullMethodName     = "/agentic.v1.UserService/CreateUser"
	UserService_GetUser_FullMethodName        = "/agentic.v1.UserService/GetUser"
	UserService_UpdateUser_FullMethodName     = "/agentic.v1.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName     = "/agentic.v1.UserService/DeleteUser"
	UserService_Authenticate_FullMethodName   = "/agentic.v1.UserService/Authenticate"
	UserService_ChangePassword_FullMethodName = "/agentic.v1.UserService/ChangePassword"
	UserService_DeactivateUser_FullMethodName = "/agentic.v1.UserService/DeactivateUser"
	UserService_GetUserRoles_FullMethodName   = "/agentic.v1.UserService/GetUserRoles"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for managing users
type UserServiceClient interface {
	// Create a new user
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Get user details by their unique identifier
	GetUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*User, error)
	// Update an existing user's details
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Delete a user by their unique identifier
	DeleteUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Authenticate a user and retrieve their details
	Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*User, error)
	// Change a user's password
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Deactivate a user account
	DeactivateUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Retrieve the roles assigned to a user
	GetUserRoles(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListRolesResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_Authenticate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserService_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeactivateUser(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserService_DeactivateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserRoles(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*ListRolesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRolesResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// Service for managing users
type UserServiceServer interface {
	// Create a new user
	CreateUser(context.Context, *User) (*User, error)
	// Get user details by their unique identifier
	GetUser(context.Context, *GetByIdRequest) (*User, error)
	// Update an existing user's details
	UpdateUser(context.Context, *User) (*User, error)
	// Delete a user by their unique identifier
	DeleteUser(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Authenticate a user and retrieve their details
	Authenticate(context.Context, *AuthenticateRequest) (*User, error)
	// Change a user's password
	ChangePassword(context.Context, *ChangePasswordRequest) (*BoolResponse, error)
	// Deactivate a user account
	DeactivateUser(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Retrieve the roles assigned to a user
	GetUserRoles(context.Context, *GetByIdRequest) (*ListRolesResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetByIdRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) Authenticate(context.Context, *AuthenticateRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedUserServiceServer) ChangePassword(context.Context, *ChangePasswordRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServiceServer) DeactivateUser(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserRoles(context.Context, *GetByIdRequest) (*ListRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Authenticate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Authenticate(ctx, req.(*AuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeactivateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeactivateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeactivateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeactivateUser(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserRoles(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "Authenticate",
			Handler:    _UserService_Authenticate_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _UserService_ChangePassword_Handler,
		},
		{
			MethodName: "DeactivateUser",
			Handler:    _UserService_DeactivateUser_Handler,
		},
		{
			MethodName: "GetUserRoles",
			Handler:    _UserService_GetUserRoles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	UserCredentialService_GetUserCredentials_FullMethodName    = "/agentic.v1.UserCredentialService/GetUserCredentials"
	UserCredentialService_SetUserCredentials_FullMethodName    = "/agentic.v1.UserCredentialService/SetUserCredentials"
	UserCredentialService_DeleteUserCredentials_FullMethodName = "/agentic.v1.UserCredentialService/DeleteUserCredentials"
)

// UserCredentialServiceClient is the client API for UserCredentialService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserCredentialServiceClient interface {
	// Get user credentials by user_id and credential_name
	GetUserCredentials(ctx context.Context, in *UserCredentialRequest, opts ...grpc.CallOption) (*UserCredential, error)
	// Set user credentials (for creating or updating credentials)
	SetUserCredentials(ctx context.Context, in *UserCredential, opts ...grpc.CallOption) (*BoolResponse, error)
	// Delete user credentials by user_id and credential_name
	DeleteUserCredentials(ctx context.Context, in *UserCredentialRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type userCredentialServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserCredentialServiceClient(cc grpc.ClientConnInterface) UserCredentialServiceClient {
	return &userCredentialServiceClient{cc}
}

func (c *userCredentialServiceClient) GetUserCredentials(ctx context.Context, in *UserCredentialRequest, opts ...grpc.CallOption) (*UserCredential, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserCredential)
	err := c.cc.Invoke(ctx, UserCredentialService_GetUserCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCredentialServiceClient) SetUserCredentials(ctx context.Context, in *UserCredential, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserCredentialService_SetUserCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userCredentialServiceClient) DeleteUserCredentials(ctx context.Context, in *UserCredentialRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserCredentialService_DeleteUserCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserCredentialServiceServer is the server API for UserCredentialService service.
// All implementations must embed UnimplementedUserCredentialServiceServer
// for forward compatibility.
type UserCredentialServiceServer interface {
	// Get user credentials by user_id and credential_name
	GetUserCredentials(context.Context, *UserCredentialRequest) (*UserCredential, error)
	// Set user credentials (for creating or updating credentials)
	SetUserCredentials(context.Context, *UserCredential) (*BoolResponse, error)
	// Delete user credentials by user_id and credential_name
	DeleteUserCredentials(context.Context, *UserCredentialRequest) (*BoolResponse, error)
	mustEmbedUnimplementedUserCredentialServiceServer()
}

// UnimplementedUserCredentialServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserCredentialServiceServer struct{}

func (UnimplementedUserCredentialServiceServer) GetUserCredentials(context.Context, *UserCredentialRequest) (*UserCredential, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserCredentials not implemented")
}
func (UnimplementedUserCredentialServiceServer) SetUserCredentials(context.Context, *UserCredential) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserCredentials not implemented")
}
func (UnimplementedUserCredentialServiceServer) DeleteUserCredentials(context.Context, *UserCredentialRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserCredentials not implemented")
}
func (UnimplementedUserCredentialServiceServer) mustEmbedUnimplementedUserCredentialServiceServer() {}
func (UnimplementedUserCredentialServiceServer) testEmbeddedByValue()                               {}

// UnsafeUserCredentialServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserCredentialServiceServer will
// result in compilation errors.
type UnsafeUserCredentialServiceServer interface {
	mustEmbedUnimplementedUserCredentialServiceServer()
}

func RegisterUserCredentialServiceServer(s grpc.ServiceRegistrar, srv UserCredentialServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserCredentialServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserCredentialService_ServiceDesc, srv)
}

func _UserCredentialService_GetUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCredentialServiceServer).GetUserCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCredentialService_GetUserCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCredentialServiceServer).GetUserCredentials(ctx, req.(*UserCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCredentialService_SetUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCredentialServiceServer).SetUserCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCredentialService_SetUserCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCredentialServiceServer).SetUserCredentials(ctx, req.(*UserCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserCredentialService_DeleteUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserCredentialServiceServer).DeleteUserCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserCredentialService_DeleteUserCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserCredentialServiceServer).DeleteUserCredentials(ctx, req.(*UserCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserCredentialService_ServiceDesc is the grpc.ServiceDesc for UserCredentialService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserCredentialService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.UserCredentialService",
	HandlerType: (*UserCredentialServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserCredentials",
			Handler:    _UserCredentialService_GetUserCredentials_Handler,
		},
		{
			MethodName: "SetUserCredentials",
			Handler:    _UserCredentialService_SetUserCredentials_Handler,
		},
		{
			MethodName: "DeleteUserCredentials",
			Handler:    _UserCredentialService_DeleteUserCredentials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	ServiceManagementService_CreateService_FullMethodName         = "/agentic.v1.ServiceManagementService/CreateService"
	ServiceManagementService_UpdateService_FullMethodName         = "/agentic.v1.ServiceManagementService/UpdateService"
	ServiceManagementService_DeleteService_FullMethodName         = "/agentic.v1.ServiceManagementService/DeleteService"
	ServiceManagementService_ListServices_FullMethodName          = "/agentic.v1.ServiceManagementService/ListServices"
	ServiceManagementService_ActivateService_FullMethodName       = "/agentic.v1.ServiceManagementService/ActivateService"
	ServiceManagementService_DeactivateService_FullMethodName     = "/agentic.v1.ServiceManagementService/DeactivateService"
	ServiceManagementService_InvokeExternalService_FullMethodName = "/agentic.v1.ServiceManagementService/InvokeExternalService"
)

// ServiceManagementServiceClient is the client API for ServiceManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceManagementServiceClient interface {
	// Create a new external service
	CreateService(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error)
	// Update an existing external service
	UpdateService(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error)
	// Delete an external service by its unique identifier
	DeleteService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// List all registered external services
	ListServices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListServicesResponse, error)
	// Activate an external service
	ActivateService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Deactivate an external service
	DeactivateService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Invoke an operation on an external service
	InvokeExternalService(ctx context.Context, in *InvokeExternalServiceRequest, opts ...grpc.CallOption) (*InvokeExternalServiceResponse, error)
}

type serviceManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceManagementServiceClient(cc grpc.ClientConnInterface) ServiceManagementServiceClient {
	return &serviceManagementServiceClient{cc}
}

func (c *serviceManagementServiceClient) CreateService(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceManagementService_CreateService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) UpdateService(ctx context.Context, in *Service, opts ...grpc.CallOption) (*Service, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceManagementService_UpdateService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) DeleteService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ServiceManagementService_DeleteService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) ListServices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesResponse)
	err := c.cc.Invoke(ctx, ServiceManagementService_ListServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) ActivateService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ServiceManagementService_ActivateService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) DeactivateService(ctx context.Context, in *GetByIdRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ServiceManagementService_DeactivateService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagementServiceClient) InvokeExternalService(ctx context.Context, in *InvokeExternalServiceRequest, opts ...grpc.CallOption) (*InvokeExternalServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvokeExternalServiceResponse)
	err := c.cc.Invoke(ctx, ServiceManagementService_InvokeExternalService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceManagementServiceServer is the server API for ServiceManagementService service.
// All implementations must embed UnimplementedServiceManagementServiceServer
// for forward compatibility.
type ServiceManagementServiceServer interface {
	// Create a new external service
	CreateService(context.Context, *Service) (*Service, error)
	// Update an existing external service
	UpdateService(context.Context, *Service) (*Service, error)
	// Delete an external service by its unique identifier
	DeleteService(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// List all registered external services
	ListServices(context.Context, *Empty) (*ListServicesResponse, error)
	// Activate an external service
	ActivateService(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Deactivate an external service
	DeactivateService(context.Context, *GetByIdRequest) (*BoolResponse, error)
	// Invoke an operation on an external service
	InvokeExternalService(context.Context, *InvokeExternalServiceRequest) (*InvokeExternalServiceResponse, error)
	mustEmbedUnimplementedServiceManagementServiceServer()
}

// UnimplementedServiceManagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServiceManagementServiceServer struct{}

func (UnimplementedServiceManagementServiceServer) CreateService(context.Context, *Service) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateService not implemented")
}
func (UnimplementedServiceManagementServiceServer) UpdateService(context.Context, *Service) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateService not implemented")
}
func (UnimplementedServiceManagementServiceServer) DeleteService(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteService not implemented")
}
func (UnimplementedServiceManagementServiceServer) ListServices(context.Context, *Empty) (*ListServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedServiceManagementServiceServer) ActivateService(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateService not implemented")
}
func (UnimplementedServiceManagementServiceServer) DeactivateService(context.Context, *GetByIdRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateService not implemented")
}
func (UnimplementedServiceManagementServiceServer) InvokeExternalService(context.Context, *InvokeExternalServiceRequest) (*InvokeExternalServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvokeExternalService not implemented")
}
func (UnimplementedServiceManagementServiceServer) mustEmbedUnimplementedServiceManagementServiceServer() {
}
func (UnimplementedServiceManagementServiceServer) testEmbeddedByValue() {}

// UnsafeServiceManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceManagementServiceServer will
// result in compilation errors.
type UnsafeServiceManagementServiceServer interface {
	mustEmbedUnimplementedServiceManagementServiceServer()
}

func RegisterServiceManagementServiceServer(s grpc.ServiceRegistrar, srv ServiceManagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedServiceManagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ServiceManagementService_ServiceDesc, srv)
}

func _ServiceManagementService_CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Service)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).CreateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_CreateService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).CreateService(ctx, req.(*Service))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_UpdateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Service)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).UpdateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_UpdateService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).UpdateService(ctx, req.(*Service))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_DeleteService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).DeleteService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_DeleteService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).DeleteService(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).ListServices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_ActivateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).ActivateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_ActivateService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).ActivateService(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_DeactivateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).DeactivateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_DeactivateService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).DeactivateService(ctx, req.(*GetByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManagementService_InvokeExternalService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeExternalServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagementServiceServer).InvokeExternalService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceManagementService_InvokeExternalService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagementServiceServer).InvokeExternalService(ctx, req.(*InvokeExternalServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceManagementService_ServiceDesc is the grpc.ServiceDesc for ServiceManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.ServiceManagementService",
	HandlerType: (*ServiceManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateService",
			Handler:    _ServiceManagementService_CreateService_Handler,
		},
		{
			MethodName: "UpdateService",
			Handler:    _ServiceManagementService_UpdateService_Handler,
		},
		{
			MethodName: "DeleteService",
			Handler:    _ServiceManagementService_DeleteService_Handler,
		},
		{
			MethodName: "ListServices",
			Handler:    _ServiceManagementService_ListServices_Handler,
		},
		{
			MethodName: "ActivateService",
			Handler:    _ServiceManagementService_ActivateService_Handler,
		},
		{
			MethodName: "DeactivateService",
			Handler:    _ServiceManagementService_DeactivateService_Handler,
		},
		{
			MethodName: "InvokeExternalService",
			Handler:    _ServiceManagementService_InvokeExternalService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	MetadataService_GetMetadata_FullMethodName    = "/agentic.v1.MetadataService/GetMetadata"
	MetadataService_SetMetadata_FullMethodName    = "/agentic.v1.MetadataService/SetMetadata"
	MetadataService_DeleteMetadata_FullMethodName = "/agentic.v1.MetadataService/DeleteMetadata"
)

// MetadataServiceClient is the client API for MetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetadataServiceClient interface {
	// Get metadata by key
	GetMetadata(ctx context.Context, in *MetadataRequest, opts ...grpc.CallOption) (*ArInternalMetadata, error)
	// Set metadata
	SetMetadata(ctx context.Context, in *ArInternalMetadata, opts ...grpc.CallOption) (*BoolResponse, error)
	// Delete metadata by key
	DeleteMetadata(ctx context.Context, in *MetadataRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type metadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMetadataServiceClient(cc grpc.ClientConnInterface) MetadataServiceClient {
	return &metadataServiceClient{cc}
}

func (c *metadataServiceClient) GetMetadata(ctx context.Context, in *MetadataRequest, opts ...grpc.CallOption) (*ArInternalMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArInternalMetadata)
	err := c.cc.Invoke(ctx, MetadataService_GetMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) SetMetadata(ctx context.Context, in *ArInternalMetadata, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, MetadataService_SetMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) DeleteMetadata(ctx context.Context, in *MetadataRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, MetadataService_DeleteMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetadataServiceServer is the server API for MetadataService service.
// All implementations must embed UnimplementedMetadataServiceServer
// for forward compatibility.
type MetadataServiceServer interface {
	// Get metadata by key
	GetMetadata(context.Context, *MetadataRequest) (*ArInternalMetadata, error)
	// Set metadata
	SetMetadata(context.Context, *ArInternalMetadata) (*BoolResponse, error)
	// Delete metadata by key
	DeleteMetadata(context.Context, *MetadataRequest) (*BoolResponse, error)
	mustEmbedUnimplementedMetadataServiceServer()
}

// UnimplementedMetadataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMetadataServiceServer struct{}

func (UnimplementedMetadataServiceServer) GetMetadata(context.Context, *MetadataRequest) (*ArInternalMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadata not implemented")
}
func (UnimplementedMetadataServiceServer) SetMetadata(context.Context, *ArInternalMetadata) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMetadata not implemented")
}
func (UnimplementedMetadataServiceServer) DeleteMetadata(context.Context, *MetadataRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMetadata not implemented")
}
func (UnimplementedMetadataServiceServer) mustEmbedUnimplementedMetadataServiceServer() {}
func (UnimplementedMetadataServiceServer) testEmbeddedByValue()                         {}

// UnsafeMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetadataServiceServer will
// result in compilation errors.
type UnsafeMetadataServiceServer interface {
	mustEmbedUnimplementedMetadataServiceServer()
}

func RegisterMetadataServiceServer(s grpc.ServiceRegistrar, srv MetadataServiceServer) {
	// If the following call pancis, it indicates UnimplementedMetadataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MetadataService_ServiceDesc, srv)
}

func _MetadataService_GetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).GetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataService_GetMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).GetMetadata(ctx, req.(*MetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_SetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArInternalMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).SetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataService_SetMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).SetMetadata(ctx, req.(*ArInternalMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_DeleteMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataService_DeleteMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, req.(*MetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetadataService_ServiceDesc is the grpc.ServiceDesc for MetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.MetadataService",
	HandlerType: (*MetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetadata",
			Handler:    _MetadataService_GetMetadata_Handler,
		},
		{
			MethodName: "SetMetadata",
			Handler:    _MetadataService_SetMetadata_Handler,
		},
		{
			MethodName: "DeleteMetadata",
			Handler:    _MetadataService_DeleteMetadata_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/huginn/simple.proto",
}

const (
	ChatService_Chat_FullMethodName = "/agentic.v1.ChatService/Chat"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatServiceClient interface {
	Chat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChatMessage, ChatMessage], error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) Chat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChatMessage, ChatMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_Chat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatMessage, ChatMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatClient = grpc.BidiStreamingClient[ChatMessage, ChatMessage]

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
type ChatServiceServer interface {
	Chat(grpc.BidiStreamingServer[ChatMessage, ChatMessage]) error
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) Chat(grpc.BidiStreamingServer[ChatMessage, ChatMessage]) error {
	return status.Errorf(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call pancis, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServiceServer).Chat(&grpc.GenericServerStream[ChatMessage, ChatMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatServer = grpc.BidiStreamingServer[ChatMessage, ChatMessage]

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agentic.v1.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _ChatService_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/proto/huginn/simple.proto",
}
